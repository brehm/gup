From 20da9e60d48983015f4e9f5d00e5b4db2ab2b8d2 Mon Sep 17 00:00:00 2001
From: Tim Cuthbertson <tim@gfxmonk.net>
Date: Fri, 3 Jul 2015 21:06:33 +1000
Subject: [PATCH 2/2] lwt_unix: add configure check to detect nanosecond stat
 support

---
 discover.ml              | 42 ++++++++++++++++++++++++++++++++++++++++++
 src/unix/lwt_unix_unix.c | 17 +++--------------
 2 files changed, 45 insertions(+), 14 deletions(-)

diff --git a/discover.ml b/discover.ml
index 8c209c3..9f7c783 100644
--- a/discover.ml
+++ b/discover.ml
@@ -230,6 +230,25 @@ CAMLprim value lwt_test()
 }
 "
 
+let struct_ns_code conversion = "
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <caml/mlvalues.h>
+
+#define NANOSEC" ^ conversion ^ "
+
+CAMLprim value lwt_test() {
+  struct stat *buf;
+  double a, m, c;
+  a = (double)NANOSEC(buf, a);
+  m = (double)NANOSEC(buf, m);
+  c = (double)NANOSEC(buf, c);
+  return Val_unit;
+}
+"
+
 (* +-----------------------------------------------------------------+
    | Compilation                                                     |
    +-----------------------------------------------------------------+ *)
@@ -536,6 +555,28 @@ let () =
     test_code (opt, lib) glib_code
   in
 
+  let test_nanosecond_stat () =
+    printf "testing for nanosecond stat support:%!";
+    let conversions = [
+      ("(buf, field) buf->st_##field##tim.tv_nsec",      "*tim.tv_nsec");
+      ("(buf, field) buf->st_##field##timespec.tv_nsec", "*timespec.tv_nsec");
+      ("(buf, field) buf->st_##field##timensec",         "*timensec");
+    ] in
+    let fallback = "(buf, field) 0.0" in
+    let conversion = try
+      let (conversion, desc) = List.find (fun (conversion, _desc) ->
+        test_code ([], []) (struct_ns_code conversion)
+      ) conversions in
+      printf " %s %s\n%!" (String.make 11 '.') desc;
+      conversion
+    with Not_found -> begin
+      printf " %s unavailable\n%!" (String.make 11 '.');
+      fprintf config "#define NANOSEC%s\n" fallback;
+      fallback
+    end in
+    fprintf config "#define NANOSEC%s\n" conversion
+  in
+
   test_feature ~do_check:!use_libev "libev" "HAVE_LIBEV" test_libev;
   test_feature ~do_check:!use_pthread "pthread" "HAVE_PTHREAD" test_pthread;
   test_feature ~do_check:!use_glib "glib" "" test_glib;
@@ -585,6 +626,7 @@ Lwt can use pthread or the win32 API.
   test_feature ~do_check "fdatasync" "HAVE_FDATASYNC" (fun () -> test_code ([], []) fdatasync_code);
   test_feature ~do_check:(do_check && not !android_target)
     "netdb_reentrant" "HAVE_NETDB_REENTRANT" (fun () -> test_code ([], []) netdb_reentrant_code);
+  test_nanosecond_stat ();
 
   let get_cred_vars = [
     "HAVE_GET_CREDENTIALS_LINUX";
diff --git a/src/unix/lwt_unix_unix.c b/src/unix/lwt_unix_unix.c
index c7ee7d7..0900481 100644
--- a/src/unix/lwt_unix_unix.c
+++ b/src/unix/lwt_unix_unix.c
@@ -931,20 +931,9 @@ static value copy_stat(int use_64, struct stat *buf)
   CAMLparam0();
   CAMLlocal5(atime, mtime, ctime, offset, v);
 
-  #if defined _BSD_SOURCE || defined _SVID_SOURCE
-    atime = caml_copy_double((double) buf->st_atime + (buf->st_atim.tv_nsec / 1000000000.0f));
-    mtime = caml_copy_double((double) buf->st_mtime + (buf->st_mtim.tv_nsec / 1000000000.0f));
-    ctime = caml_copy_double((double) buf->st_ctime + (buf->st_ctim.tv_nsec / 1000000000.0f));
-  #elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)
-    atime = caml_copy_double((double) buf->st_atime + (buf->st_atimespec.tv_nsec / 1000000000.0f));
-    mtime = caml_copy_double((double) buf->st_mtime + (buf->st_mtimespec.tv_nsec / 1000000000.0f));
-    ctime = caml_copy_double((double) buf->st_ctime + (buf->st_ctimespec.tv_nsec / 1000000000.0f));
-  #else
-    atime = caml_copy_double((double) buf->st_atime + (buf->st_atimensec / 1000000000.0f));
-    mtime = caml_copy_double((double) buf->st_mtime + (buf->st_mtimensec / 1000000000.0f));
-    ctime = caml_copy_double((double) buf->st_ctime + (buf->st_ctimensec / 1000000000.0f));
-  #endif
-
+  atime = copy_double((double) buf->st_atime + (NANOSEC(buf, a) / 1000000000.0));
+  mtime = copy_double((double) buf->st_mtime + (NANOSEC(buf, m) / 1000000000.0));
+  ctime = copy_double((double) buf->st_ctime + (NANOSEC(buf, c) / 1000000000.0));
   offset = use_64 ? caml_copy_int64(buf->st_size) : Val_int(buf->st_size);
   v = alloc_small(12, 0);
   Field(v, 0) = Val_int (buf->st_dev);
-- 
2.5.0

